<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="false" > 
<link href="/fontawesome/css/fontawesome.css" rel="stylesheet">
<link href="/fontawesome/css/brands.css" rel="stylesheet">
<link href="/fontawesome/css/solid.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  

  
  <title>ROCA攻击——CVE-2017-15361 | crumbling&#39;s secret room</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" href="/css/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/MaterialSymbolsRounded.woff2" as="font" type="font/woff2" crossorigin="anonymous">

  <meta name="description" content="2023WMCTF的badprime官方wp提到了这个漏洞CVE-2017-15361。 badprime源码： 12345678910111213141516171819202122232425from Crypto.Util.number import *from secret import flag M &#x3D; 0x7cda79f57f60a9b65478052f383ad7dadb714b4f">
<meta property="og:type" content="article">
<meta property="og:title" content="ROCA攻击——CVE-2017-15361">
<meta property="og:url" content="http://example.com/2023/09/06/ROCA%E6%94%BB%E5%87%BB%E2%80%94%E2%80%94CVE-2017-15361/index.html">
<meta property="og:site_name" content="crumbling&#39;s secret room">
<meta property="og:description" content="2023WMCTF的badprime官方wp提到了这个漏洞CVE-2017-15361。 badprime源码： 12345678910111213141516171819202122232425from Crypto.Util.number import *from secret import flag M &#x3D; 0x7cda79f57f60a9b65478052f383ad7dadb714b4f">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-09-06T10:15:27.399Z">
<meta property="article:modified_time" content="2023-09-06T10:23:13.498Z">
<meta property="article:author" content="crumbling">
<meta property="article:tag" content="-Crypto">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="crumbling's secret room" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-192.png" sizes="192x192">
  
  
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body>
  
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>crumbling's secret room </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="material-symbols-rounded light-mode-icon">wb_sunny</span>
      <span class="material-symbols-rounded dark-mode-icon">dark_mode</span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS 订阅">
        <span class="material-symbols-rounded rss">rss_feed</span>
      </a>
    
    <a id="nav-search-btn" class="nav-icon" title="搜索" style="display: none;">
      <span class="material-symbols-rounded">search</span>
    </a>
    <div id="nav-menu-btn" class="nav-icon">
      <span class="material-symbols-rounded">menu</span>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS 订阅">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">crumbling </div>
      <div class="dot"></div>
      <div class="subtitle">This is the subtitle </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://twitter.com" title="Twitter"><i class="fa-brands fa-twitter"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://steamcommunity.com/profiles/76561199334949091/" title="Steam"><i class="fa-brands fa-steam"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/fcrumbling" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      



    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">标签</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Crypto/" rel="tag">-Crypto</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/web-%E5%BC%80%E5%8F%91/" rel="tag">-web -开发</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/" rel="tag">-自我介绍</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/Crypto/" rel="tag">Crypto</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/gb%E5%9F%BA/" rel="tag">gb基</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/hnp/" rel="tag">hnp</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E6%A0%BC%E5%AF%86%E7%A0%81/" rel="tag">格密码</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/" rel="tag">深度搜索</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E7%9B%B8%E5%85%B3%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB/" rel="tag">相关明文攻击</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" rel="tag">背包问题</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E9%9B%85%E5%85%8B%E6%AF%94%E7%AC%A6%E5%8F%B7/" rel="tag">雅克比符号</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/tags/%E9%AB%98%E6%96%AF%E5%90%AF%E5%8F%91%E5%BC%8F/" rel="tag">高斯启发式</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">归档</h3>
      
      
        <a class="archive-link" href="/archives/2023/11 ">
          十一月 2023 
          <div class="archive-count">2 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/10 ">
          十月 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2023/09 ">
          九月 2023 
          <div class="archive-count">5 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">最新文章</h3>
      <ul>
        
          <a class="recent-link" href="/2023/11/12/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E9%9A%8F%E6%89%8B%E8%AE%B01/" title="开发学习随手记（一）" >
            <div class="recent-link-text">
              开发学习随手记（一）
            </div>
          </a>
        
          <a class="recent-link" href="/2023/11/02/2023ACTF-crypto%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/" title="2023ACTF——Crypto题目复现" >
            <div class="recent-link-text">
              2023ACTF——Crypto题目复现
            </div>
          </a>
        
          <a class="recent-link" href="/2023/10/29/DASCTF-CBCTF-crypto%E9%83%A8%E5%88%86%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/" title="DASCTF-CBCTF-crypto部分赛题复现" >
            <div class="recent-link-text">
              DASCTF-CBCTF-crypto部分赛题复现
            </div>
          </a>
        
          <a class="recent-link" href="/2023/09/20/2023WMCTF%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/" title="2023WMCTF——Crypto部分题目复现" >
            <div class="recent-link-text">
              2023WMCTF——Crypto部分题目复现
            </div>
          </a>
        
          <a class="recent-link" href="/2023/09/19/LFSR/" title="LFSR学习" >
            <div class="recent-link-text">
              LFSR学习
            </div>
          </a>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       

<article id="post-ROCA攻击——CVE-2017-15361" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        ROCA攻击——CVE-2017-15361
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2023-09-06T10:15:27.399Z" itemprop="datePublished">2023-09-06</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
    未分类 
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            2.9k 词 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Crypto/" rel="tag">-Crypto</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <p>2023WMCTF的badprime官方wp提到了这个漏洞CVE-2017-15361。</p>
<h2 id="badprime"><a href="#badprime" class="headerlink" title="badprime"></a><h2 id='2'>badprime</h2></h2><p><strong>源码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"> </span><br><span class="line">M = <span class="number">0x7cda79f57f60a9b65478052f383ad7dadb714b4f4ac069997c7ff23d34d075fca08fdf20f95fbc5f0a981d65c3a3ee7ff74d769da52e948d6b0270dd736ef61fa99a54f80fb22091b055885dc22b9f17562778dfb2aeac87f51de339f71731d207c0af3244d35129feba028a48402247f4ba1d2b6d0755baff6</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getMyprime</span>(<span class="params">BIT</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        p = <span class="built_in">int</span>(<span class="built_in">pow</span>(<span class="number">65537</span>, getRandomRange(M&gt;&gt;<span class="number">1</span>, M), M)) + getRandomInteger(BIT-<span class="built_in">int</span>(M).bit_length()) * M</span><br><span class="line">        <span class="keyword">if</span> isPrime(p):</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line"> </span><br><span class="line">p = getMyprime(<span class="number">1024</span>)</span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br><span class="line">n = p * q</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Try to crack the bad RSA&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Public key:&quot;</span>, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The flag(encrypted):&quot;</span>, <span class="built_in">pow</span>(m, <span class="number">65537</span>, n))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Well well, I will give you the hint if you please me ^_^&quot;</span>)</span><br><span class="line">leak = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Gift window:&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> M % leak == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is the gift for you: &quot;</span>, p % leak)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I don&#x27;t like this gift!&quot;</span>)</span><br></pre></td></tr></table></figure>



<p><strong>题解：</strong></p>
<p>这题传M然后copper，很简单。但是官wp提到了个cve，想来看看怎么个事。</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">M = <span class="number">0x7cda79f57f60a9b65478052f383ad7dadb714b4f4ac069997c7ff23d34d075fca08fdf20f95fbc5f0a981d65c3a3ee7ff74d769da52e948d6b0270dd736ef61fa99a54f80fb22091b055885dc22b9f17562778dfb2aeac87f51de339f71731d207c0af3244d35129feba028a48402247f4ba1d2b6d0755baff6</span></span><br><span class="line">gift = <span class="number">10024313384012746250694208538949686447032355241059569161518116640903009793798604684812989972951794463837898271416656747821246172846318000100642976088351263390343566563706839156952569571295913267481277331199225506966486951661539619597002534258121910069983897789675728728232822162150931695346789</span></span><br><span class="line">N = <span class="number">4527815560823898629090647633115302565837083515415976989690995912533144402828153290938790009126615705345926094457204119165604978427936576957465024752372112088234196073103717618632250550457634287834840701441955152299257503315744314335307821065466785930677769272236861589143544968634247690966457155973029019492515848925422374199922226662095089357969581197472453406092735214388947778181441370905665865989787799516773111366231899212901002557397391641026737581811832827350154376098191096933368295719329855350653664823378217291487968979523352051265095565946743081123073185487467693023515416676113819101085553626421514061953</span></span><br><span class="line"></span><br><span class="line">maxlen = <span class="number">1024</span> -<span class="built_in">len</span>(<span class="built_in">bin</span>(M)[<span class="number">2</span>:])</span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(N))</span><br><span class="line">f = gift + M*x</span><br><span class="line">root = f.monic().small_roots(X=<span class="number">2</span>**maxlen, beta=<span class="number">0.42</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(root)</span><br><span class="line">p = <span class="built_in">int</span>(f(x=root))</span><br><span class="line">q = N // p</span><br><span class="line"><span class="keyword">assert</span> p*q == N</span><br><span class="line"></span><br><span class="line">c = <span class="number">671423126344208979817020905319387107659521538401974581808466400658740425949121176339811220873187770177211049553654784310187701419630988633907039522390923642257247011797390197264431099444628550241370342966809803434077602089915863876682573081967204200944311396918398626099269491924960069539014293172012589912456689762187833047695244229784895185860115454875875027756981261009120804422582439068086000037380136289751308973297117752176034134418622366871665313790352235666401502989780634803665475527926954123107148643985437557292021664410162756392459081674875458282375811451846338551390975585916239510041697895364036127409</span></span><br><span class="line">d = inverse_mod(<span class="number">65537</span>, (p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(<span class="built_in">pow</span>(c, d, N))))</span><br></pre></td></tr></table></figure>



<h3 id="ROCA攻击"><a href="#ROCA攻击" class="headerlink" title="ROCA攻击:"></a>ROCA攻击:</h3><p>以下内容主要参考<a target="_blank" rel="noopener" href="https://bitsdeep.com/posts/analysis-of-the-roca-vulnerability/">Analysis of the ROCA vulnerability | BitsDeep</a></p>
<p>在 RSALib 的情况下，质数具有特殊的形式：<em>p</em>&#x3D;<em>k</em>⋅<em>M</em>+(65537^a^mod<em>M</em>)。 其中，参数 k 和 a 未知，M 是一个素数阶乘（前 n 个连续素数的乘积）。</p>
<p>文章提供了一个表格：</p>
<table>
<thead>
<tr>
<th>key size</th>
<th>n</th>
<th>M</th>
</tr>
</thead>
<tbody><tr>
<td>512-960</td>
<td>39</td>
<td>P<del>39#</del></td>
</tr>
<tr>
<td>992-1952</td>
<td>71</td>
<td>P<del>71#</del></td>
</tr>
<tr>
<td>1984-3936</td>
<td>126</td>
<td>P<del>126#</del></td>
</tr>
<tr>
<td>3968-4096</td>
<td>225</td>
<td>P<del>225#</del></td>
</tr>
</tbody></table>
<p>这种生成方法存在问题，以512位N，g&#x3D;65537举例（下面都是）。</p>
<p>此时M&#x3D;P<del>39#</del>约219bit，p为256bit，可见k约37bit。</p>
<p>而对于a，求满足g^k^&#x3D;1 mod M的最小非0正整数k，可知a约在62bit</p>
<p>文中提供了sage代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = <span class="number">65537</span></span><br><span class="line">k = Zmod(M)(g).multiplicative_order()</span><br><span class="line"><span class="built_in">print</span>(log(k, <span class="number">2</span>).n())</span><br><span class="line"><span class="comment">#61.0899035000874</span></span><br></pre></td></tr></table></figure>

<p>即相对于256bit素数的2^256^种可能性，该方法生成的p只有2^99^种</p>
<p>然后文中提到了一些在研究中发现的特殊性质，略过。</p>
<p>随后文中提到了两种检测一个密钥是否易受 ROCA 攻击：</p>
<ul>
<li><p>第一种方法基于前文提到的特殊性质——N 被限制在模小素数的小余数集合</p>
</li>
<li><p>第二种更好的方法基于求解log<del>65537</del><em>N</em> mod <em>M</em>以及前文提到的一个性质N&#x3D;65537^a^ mod M。</p>
<ul>
<li><p>因为M是个光滑数，所以 Pohlig-Hellman算法可以快速求解。</p>
</li>
<li><p>以下是文中提供的相关检测代码,实现了给定一个n，自动生成对应的M并求解log<del>65537</del><em>N</em> mod <em>M</em></p>
</li>
<li><pre><code class="python">def isVuln(n):
    params = getParameterSizes(n.bit_length())
    if params is not None:
        M = params[0]
        try:
            a = Zmod(M)(n).log(65537)
            print(f&quot;Vulnerable Key ! Found a=&#123;a&#125;&quot;)
            return True
        except ValueError:
            print(&quot;Key not vulnerable to ROCA :(&quot;)
            return False

# test a vulnerable key
isVuln(genWeakKey(512))

# Now test a normal key
from Crypto.Util.number import getPrime
notvuln = int(getPrime(300)*getPrime(300))

isVuln(notvuln)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### **攻击原理：**</span><br><span class="line"></span><br><span class="line">感觉这一部分有点乱，大概是解释了coppersmith，然后实现了给定a的情况下求解k，但用的是比较复杂（指参数较多）的coppersmith_howgrave_univariate函数，而不是small_roots。</span><br><span class="line"></span><br><span class="line">直接看优化部分吧，有提到优化部分会缩小a的可能范围。</span><br><span class="line"></span><br><span class="line">##### **优化1：**</span><br><span class="line"></span><br><span class="line">缩小搜索范围。 （后文：一个不大的优化）</span><br><span class="line"></span><br><span class="line">文中有提到两个性质，这里用到其中一个：模数 *N* 与其素因子具有相同的形式，即*N*=*k*~3~⋅*M*+(65537^a^mod*M*);其中a≡a1+a2 mod |G|,G是由 65537(模M) 生成的Z~m~的子群，a1、a2是素因子生成时的指数值。</span><br><span class="line"></span><br><span class="line">&gt; 原本a~1~（a~2~）的搜索范围是 [0, a] ，但根据a≡a~1~+a~2~ mod |G|，我们可以缩小为[a/2,（a+∣*G*∣）/2]。因为 a~1~=a~2~=a/2 是可以产生 a 的最小组合，而a~1~=*a*~2~=(*a*+∣*G*∣ )/2是最大的组合。</span><br><span class="line"></span><br><span class="line">|G|是乘法阶，应该就是个数，这个&#x27;&#x27;||&#x27;&#x27;符号不知道干什么的；同余式看成a+k|G|=a~1~+a~2~，然后结合实际的一些隐性条件，大概就出来了上面的结论。</span><br><span class="line"></span><br><span class="line">&gt; 对于其他所有组合，只有 *a*~1~ 或 *a*~2~ 中的一个会在这个区间内，但是只要我们在正确的情况下猜测了*a*~1~ 或*a*~2~，就不会有问题。</span><br><span class="line"></span><br><span class="line">这里的其他组合大概是a~1~≠a~2~吧，意思大概是不管什么情况，总有个崽种落在缩小后的区间里，能找到a~1~或a~2~，也就能求出p或q，然后成功分解N。</span><br><span class="line"></span><br><span class="line">但是和后面说的又有些矛盾，在案例中，没落在范围中的a1被求出来了，范围中的a2却没求出来q，为了同时求出，修改参数beta为0.1。但既然有p了,验证一下直接q=N//p就行了吧，这样反倒和上一段的求出a~1~或a~2~即可分解N比较符合。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### coppersmith_howgrave_univariate：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">def coppersmith_howgrave_univariate(pol, modulus, beta, mm, tt, XX):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Taken from https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/coppersmith.sage</span><br><span class="line">    Removed unnecessary stuff</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    dd = pol.degree()</span><br><span class="line">    nn = dd * mm + tt</span><br><span class="line">    </span><br><span class="line">    if not 0 &lt; beta &lt;= 1:</span><br><span class="line">        raise ValueError(&quot;beta should belongs in (0, 1]&quot;)</span><br><span class="line"></span><br><span class="line">    if not pol.is_monic():</span><br><span class="line">        raise ArithmeticError(&quot;Polynomial must be monic.&quot;)</span><br><span class="line"></span><br><span class="line">    # change ring of pol and x</span><br><span class="line">    polZ = pol.change_ring(ZZ)</span><br><span class="line">    x = polZ.parent().gen()</span><br><span class="line"></span><br><span class="line">    # compute polynomials</span><br><span class="line">    gg = []</span><br><span class="line">    for ii in range(mm):</span><br><span class="line">        for jj in range(dd):</span><br><span class="line">            gg.append((x * XX)**jj * modulus**(mm - ii) * polZ(x * XX)**ii)</span><br><span class="line">    for ii in range(tt):</span><br><span class="line">        gg.append((x * XX)**ii * polZ(x * XX)**mm)</span><br><span class="line">    </span><br><span class="line">    # construct lattice B</span><br><span class="line">    BB = Matrix(ZZ, nn)</span><br><span class="line"></span><br><span class="line">    for ii in range(nn):</span><br><span class="line">        for jj in range(ii+1):</span><br><span class="line">            BB[ii, jj] = gg[ii][jj]</span><br><span class="line">            </span><br><span class="line">    # LLL</span><br><span class="line">    BB = BB.LLL()</span><br><span class="line"></span><br><span class="line">    # transform shortest vector in polynomial    </span><br><span class="line">    new_pol = 0</span><br><span class="line">    for ii in range(nn):</span><br><span class="line">        new_pol += x**ii * BB[0, ii] / XX**ii</span><br><span class="line"></span><br><span class="line">    # factor polynomial</span><br><span class="line">    potential_roots = new_pol.roots()</span><br><span class="line"></span><br><span class="line">    # test roots</span><br><span class="line">    roots = []</span><br><span class="line">    for root in potential_roots:</span><br><span class="line">        if root[0].is_integer():</span><br><span class="line">            result = polZ(ZZ(root[0]))</span><br><span class="line">            if gcd(modulus, result) &gt;= modulus^beta:</span><br><span class="line">                roots.append(ZZ(root[0]))</span><br><span class="line">                </span><br><span class="line">    return roots</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h6 id="solve函数："><a href="#solve函数：" class="headerlink" title="solve函数："></a>solve函数：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">M, n, a, m, t, beta</span>):</span><br><span class="line">    base = <span class="built_in">int</span>(<span class="number">65537</span>)</span><br><span class="line">    <span class="comment"># the known part of p: 65537^a * M^-1 (mod N)</span></span><br><span class="line">    known = <span class="built_in">int</span>(<span class="built_in">pow</span>(base, a, M) * inverse_mod(M, n))</span><br><span class="line">    <span class="comment"># Create the polynomial f(x)</span></span><br><span class="line">    F = PolynomialRing(Zmod(n), implementation=<span class="string">&#x27;NTL&#x27;</span>, names=(<span class="string">&#x27;x&#x27;</span>,))</span><br><span class="line">    (x,) = F._first_ngens(<span class="number">1</span>)</span><br><span class="line">    pol = x + known</span><br><span class="line">    <span class="comment"># Upper bound for the small root x0</span></span><br><span class="line">    XX = floor(<span class="number">2</span> * n^<span class="number">0.5</span> / M)</span><br><span class="line">    <span class="comment"># Find a small root (x0 = k) using Coppersmith&#x27;s algorithm</span></span><br><span class="line">    roots = coppersmith_howgrave_univariate(pol, n, beta, m, t, XX)</span><br><span class="line">    <span class="comment"># There will be no roots for an incorrect guess of a.</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> roots:</span><br><span class="line">        <span class="comment"># reconstruct p from the recovered k</span></span><br><span class="line">        p = <span class="built_in">int</span>(k*M + <span class="built_in">pow</span>(base, a, M))</span><br><span class="line">        <span class="keyword">if</span> n%p == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> p, n//p</span><br></pre></td></tr></table></figure>

<h6 id="提供的案例："><a href="#提供的案例：" class="headerlink" title="提供的案例："></a>提供的案例：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Gen 2 week primes</span></span><br><span class="line"><span class="comment"># I&#x27;m not generating the key directly because I need to know the primes</span></span><br><span class="line"><span class="comment"># in order to calculate the right value for a</span></span><br><span class="line">M, k_s, a_s = getParameterSizes(<span class="number">512</span>)</span><br><span class="line"><span class="comment">#p = genWeakPrime(M, k_s, a_s)</span></span><br><span class="line"><span class="comment">#q = genWeakPrime(M, k_s, a_s)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Those values were generated using the lines above</span></span><br><span class="line"><span class="comment">#I just kept the ones that produced the desired behaviour</span></span><br><span class="line">p = <span class="number">121581495375123779193452413925265932089610720448703103558690293198717539850471</span></span><br><span class="line">q = <span class="number">116416434871278081772053124243609476193526753637462138632814719321940358203829</span></span><br><span class="line">n = p*q</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;n: <span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;p: <span class="subst">&#123;p&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;q: <span class="subst">&#123;q&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;p &gt; q: <span class="subst">&#123;p &gt; q&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">a3 = Zmod(M)(n).log(<span class="number">65537</span>)</span><br><span class="line">order = Zmod(M)(<span class="number">65537</span>).multiplicative_order()</span><br><span class="line">inf = a3//<span class="number">2</span></span><br><span class="line">sup = (a3+order)//<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;interval : [<span class="subst">&#123;inf&#125;</span>, <span class="subst">&#123;sup&#125;</span>]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># attempt to find p</span></span><br><span class="line"><span class="comment"># Compute the right values for a and k</span></span><br><span class="line">a1 = <span class="built_in">int</span>(Zmod(M)(p).log(<span class="number">65537</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a1: <span class="subst">&#123;a1&#125;</span>. In interval: <span class="subst">&#123;inf &lt;= a1 &lt;= sup&#125;</span>&quot;</span>)</span><br><span class="line">k = (p - <span class="built_in">int</span>(<span class="built_in">pow</span>(<span class="number">65537</span>, a1, M))) // M</span><br><span class="line"><span class="comment"># Assert correctness of the values</span></span><br><span class="line"><span class="keyword">assert</span>(k*M + <span class="built_in">pow</span>(<span class="number">65537</span>, a1, M) == p)</span><br><span class="line"><span class="comment"># solve using the parameters from the paper</span></span><br><span class="line">factors = solve(M, n, a1, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0.5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Known p: <span class="subst">&#123;factors&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># attempt to find q</span></span><br><span class="line"><span class="comment"># Compute the right values for a and k</span></span><br><span class="line">a2 = <span class="built_in">int</span>(Zmod(M)(q).log(<span class="number">65537</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a2: <span class="subst">&#123;a2&#125;</span>. In interval: <span class="subst">&#123;inf &lt;= a2 &lt;= sup&#125;</span>&quot;</span>)</span><br><span class="line">k = (q - <span class="built_in">int</span>(<span class="built_in">pow</span>(<span class="number">65537</span>, a2, M))) // M</span><br><span class="line"><span class="comment"># Assert correctness of the values</span></span><br><span class="line"><span class="keyword">assert</span>(k*M + <span class="built_in">pow</span>(<span class="number">65537</span>, a2, M) == q)</span><br><span class="line"><span class="comment"># solve using the parameters from the paper</span></span><br><span class="line">factors = solve(M, n, a2, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0.5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Known q: <span class="subst">&#123;factors&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h6 id="优化后的案例："><a href="#优化后的案例：" class="headerlink" title="优化后的案例："></a>优化后的案例：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># attempt to find p</span></span><br><span class="line"><span class="comment"># Compute the right values for a and k</span></span><br><span class="line">a1 = <span class="built_in">int</span>(Zmod(M)(p).log(<span class="number">65537</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a1: <span class="subst">&#123;a1&#125;</span>. In interval: <span class="subst">&#123;inf &lt;= a1 &lt;= sup&#125;</span>&quot;</span>)</span><br><span class="line">k = (p - <span class="built_in">int</span>(<span class="built_in">pow</span>(<span class="number">65537</span>, a1, M))) // M</span><br><span class="line"><span class="comment"># Assert correctness of the values</span></span><br><span class="line"><span class="keyword">assert</span>(k*M + <span class="built_in">pow</span>(<span class="number">65537</span>, a1, M) == p)</span><br><span class="line"><span class="comment"># solve using a smaller beta</span></span><br><span class="line">factors = solve(M, n, a1, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0.1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Known p: <span class="subst">&#123;factors&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># attempt to find q</span></span><br><span class="line"><span class="comment"># Compute the right values for a and k</span></span><br><span class="line">a2 = <span class="built_in">int</span>(Zmod(M)(q).log(<span class="number">65537</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a2: <span class="subst">&#123;a2&#125;</span>. In interval: <span class="subst">&#123;inf &lt;= a2 &lt;= sup&#125;</span>&quot;</span>)</span><br><span class="line">k = (q - <span class="built_in">int</span>(<span class="built_in">pow</span>(<span class="number">65537</span>, a2, M))) // M</span><br><span class="line"><span class="comment"># Assert correctness of the values</span></span><br><span class="line"><span class="keyword">assert</span>(k*M + <span class="built_in">pow</span>(<span class="number">65537</span>, a2, M) == q)</span><br><span class="line"><span class="comment"># solve using a smaller beta</span></span><br><span class="line">factors = solve(M, n, a2, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0.1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Known q: <span class="subst">&#123;factors&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="优化2："><a href="#优化2：" class="headerlink" title="优化2："></a><strong>优化2：</strong></h5><p>调整M的值。（主要的优化）</p>
<p>类比已知p高位的coppersmith，此处M的大小类似于p已知位数的数量。</p>
<p>前面提到的此处利用coppersmith求解的条件是log<del>2</del>(M) &gt; log<del>2</del>(N)&#x2F;4，实际中的M要比这个需求的值大不少，为减少搜索空间，寻找一个更小的M‘，以满足：（这里好像没有证明更小的M和减少搜索空间的关系<del>也可能是我学的太少了一眼看不出来</del>）</p>
<ul>
<li>N的因子与先前相同的形式（M’必须是M的除数）；</li>
<li>可以使用CHG（log<del>2</del>(M) &gt; log<del>2</del>(N)&#x2F;4）；</li>
<li>攻击的运行时间是最小的（尝试次数和每次尝试的时间应产生最小的时间）。</li>
</ul>
<p>对于512位密钥，M中有39个因子，因此有2^39^个M的除数，无法全部测试。</p>
<blockquote>
<p>但可以寻找由65537生成的群G’的阶|G’|（应该是对应M’）。事实上，|G’|是|G|的除数，而|G|本身是M的除数，因此其搜索空间较小：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">primorial</span>(<span class="params">n</span>):</span><br><span class="line">    M = <span class="number">1</span></span><br><span class="line">    p = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        p = next_prime(p)</span><br><span class="line">        M *= p</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(M)</span><br><span class="line">M = primorial(<span class="number">39</span>)</span><br><span class="line"><span class="built_in">print</span>(M)</span><br><span class="line"><span class="built_in">print</span>(number_of_divisors(M))</span><br><span class="line">order = Zmod(M)(<span class="number">65537</span>).multiplicative_order()</span><br><span class="line"><span class="built_in">print</span>(order,M%order)</span><br><span class="line"><span class="built_in">print</span>(number_of_divisors(order))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">962947420735983927056946215901134429196419130606213075415963491270</span></span><br><span class="line"><span class="string">549755813888  =2**39</span></span><br><span class="line"><span class="string">2454106387091158800 1538361133389550470</span></span><br><span class="line"><span class="string">76800</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>意思大概是M‘可能值（549755813888）太多，直接测试很困难;而M‘对应的|G’|也是M对应的|G|的因子，又因为|G|的因子的可能值（76800）比较小，所以就比较好爆破。（因为一个|G‘|对应多个M’）</p>
<p>然后|G|是M除数这边好像不是很对，上面代码注释里有结果，不是0。 不懂内~~</p>
<p>总之，遍历全部|G|因子，用以下函数寻找|G‘|对应的最大M’</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recover_M_prime_from_order</span>(<span class="params">M, order</span>):</span><br><span class="line">    M_prime = M</span><br><span class="line">    <span class="keyword">for</span> p, e <span class="keyword">in</span> factor(M):</span><br><span class="line">        ordP = Zmod(p)(<span class="number">65537</span>).multiplicative_order()</span><br><span class="line">        <span class="keyword">if</span> order % ordP != <span class="number">0</span>:</span><br><span class="line">            M_prime /= p</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(M_prime)</span><br></pre></td></tr></table></figure>

<p>M所有素因子对应的阶若不为|G|的因子则剔除，这里似乎还是没有解释完原理。</p>
<p>对M‘的寻找：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">M = primorial(<span class="number">39</span>)</span><br><span class="line"></span><br><span class="line">order = Zmod(M)(<span class="number">65537</span>).multiplicative_order()</span><br><span class="line">di = divisors(order)<span class="comment">#order的全部正整数因子</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Number of divisor of the order of M: <span class="subst">&#123;<span class="built_in">len</span>(di)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用pickle保存结果，以便在更改代码时无需重新计算</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    M_ps = pickle.load(<span class="built_in">open</span>(<span class="string">&quot;save.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>))</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="comment"># 计算足够大的所有M_p</span></span><br><span class="line">    M_ps = []</span><br><span class="line">    treshold = log(n, <span class="number">2</span>)/<span class="number">4</span></span><br><span class="line">    f = factor(M)</span><br><span class="line">    <span class="keyword">for</span> ordp <span class="keyword">in</span> di:</span><br><span class="line">        M_p = recover_M_prime_from_order(M, ordp)<span class="comment">#这个函数的实现似乎没有</span></span><br><span class="line">        <span class="keyword">if</span> log(M_p, <span class="number">2</span>) &gt;= treshold:</span><br><span class="line">            M_ps.append(M_p)</span><br><span class="line">    M_ps.sort()</span><br><span class="line">    pickle.dump(M_ps, <span class="built_in">open</span>(<span class="string">&quot;save.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Number of possible M&#x27;: <span class="subst">&#123;<span class="built_in">len</span>(M_ps)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Number of divisor of the order of M: 76800</span></span><br><span class="line"><span class="string">Number of possible M&#x27;: 13004</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后进行了测试，指出512位的密钥下，coppersmith_howgrave_univariate的参数m&#x3D;5为最佳</p>
<p>后面又是一些测试。</p>
<p>———————————————————————————分割线—————————————————————————————</p>
<p>对于这篇二手文章的翻译与学习结束了，觉得有些原理没解释的部分应该可以在原论文找到。</p>
<p>总结：</p>
<ul>
<li><p>偷了个懒没有直接看论文而是看了二手文章；</p>
</li>
<li><p>二手文章确实存在一些问题，不过第一次完整翻译看完一篇类似论文的全英文文章还是值得高兴的；</p>
</li>
<li><blockquote>
<p>其做法是通过提交65537的阶在其上较⼩的M的因⼦，就可以让a很⼩</p>
</blockquote>
<ul>
<li>官方wp中这段甚至不通顺的话大概就是优化2了，提交的大概是上文中的最佳M’</li>
</ul>
</li>
<li><p>本意是想要学完后改个题出来的,但是没有什么特别好的想法，而且感觉学的也不是很通透，害怕题改着改着就成了coppersmith而不是ROCA了。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://crocs.fi.muni.cz/_media/public/papers/nemec_roca_ccs17_preprint.pdf">The Return of Coppersmith’s Attack:Practical Factorization of Widely Used RSA Moduli (muni.cz)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_51999772/article/details/123146784">GKCTF2020_Crypto_复现_roca漏洞_M3ng@L的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/ROCA_vulnerability">ROCA vulnerability - Wikipedia</a></p>
<p><a target="_blank" rel="noopener" href="https://www.codeleading.com/article/91434906140/#google_vignette">GKCTF2020]Backdoor - 代码先锋网 (codeleading.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://medium.com/asecuritysite-when-bob-met-alice/so-what-was-the-problem-with-the-estonian-id-system-and-tpms-1ef02a9bde7f">那么爱沙尼亚身份证系统和TPM的问题是什么？弱素数生成器（和 RSA！ |作者：比尔·布坎南教授 OBE |A安全网站：当鲍勃遇见爱丽丝 |中等 (medium.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/FlorianPicca/ROCA">FlorianPicca&#x2F;ROCA: A Sage implementation of the ROCA attack (github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/FlorianPicca/ROCA">https://github.com/FlorianPicca/ROCA</a></p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/2023/09/06/Hello/"
      title="Hello!"
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        Hello!
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2023/09/06/2023DSACTF-Crypto%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/"
      title="2023DSACTF——Crypto题目复现"
     >

    <p class="title-text">
      
        2023DSACTF——Crypto题目复现
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>

 
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2023 crumbling<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn hide" onclick="topFunction()">
        <span class="material-symbols-rounded">keyboard_arrow_up</span>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.classList.remove('hide')
        } else {
            btn.classList.add('hide')
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
